# 연결리스트(LinkedList) 예상 질문

1. 연결리스트란 무엇인가?
2. 단일 연결 리스트, 이중 연결 리스트, 원형 연결 리스트에 대해 설명하시오.
3. Array와 LinkedList의 차이는 무엇인가? (장/단점을 중점적으로 서술)
4. 정렬되어 있지 않은 LinkedList의 중복되는 데이터를 제거하는 알고리즘을 설명하시오. (버퍼 사용 X)
5. 단방향 LinkedList의 마지막에서 k번째 노드를 찾는 알고리즘을 설명하시오.
6. 단방향 LinkedList에서 중간에 있는 노드를 삭제하는 방법을 설명하시오.  
    (단, 첫 번째 노드를 알 수 없고 오직 삭제할 노드만을 알고 있다.)
7. LinkedList에 있는 노드들을 입력 받은 값을 기준으로 작은 것은 왼쪽으로, 크거나 같은 것은 오른쪽으로 나누는 알고리즘을 설명하시오.
8. (기본문제) 어떤 숫자를 일의 자리가 헤더에 오도록 거꾸로하여 자리수 별로 한개씩 Linked List에 담았다. 이런 식의 Linked List 두개를 받아서 합산하고 같은 식으로 Linked List에 담아서 반환하는 알고리즘을 설명하시오.  
  (심화문제) 위의 문제상황에서 두 숫자가 LinkedList에 똑바로 담겨있을 때 합산하고 같은 식으로 Linked List에 담아서 반환하는 알고리즘을 설명하시오.
9. Linked List의 노드들이 회문(Palindrome)인지 확인하는 알고리즘을 설명하시오.
10. 원형 연결 리스트 내의 임의의 노드 하나가 주어졌을 때 해당 List의 길이를 효율적으로 구하는 방법을 설명하시오.
11. 두 개의 단방향 LinkedList가 교차하는지 확인하고 교차할경우 교차하는 노드를 반환하는 알고리즘을 설명하시오.
12. Linked List 안에 루프가 있는지 판단하고 루프가 있다면 루프가 시작되는 노드를 찾는 알고리즘을 설명하시오.



---


1. 원소들을 저장할 때 그 다음 원소가 있는 위치를 포함시키는 방식으로 저장하는 자료구조  

2. 단일 연결 리스트(Singly Linked List): 각 원소가 자신의 다음 원소의 주소를 가지고 있음  
    이중 연결 리스트(Doubly Linked List): 각 원소가 자신의 이전 원소와 다음 원소의 주소를 둘 다 가지고 있음  
    원형 연결 리스트(Circular Linked List): 마지막 원소가 처음 원소와 연결되어 있음 (단일 연결 리스트, 이중 연결 리스트 모두 가능)

3. 
    ||배열|연결리스트|
    |:---:|:---:|:---:|
    |k번째 원소의 접근|O(1)|O(k)|
    |임의 위치에 원소 추가/제거|O(N)|O(1)*|
    |메모리 상의 배치|연속|불연속|
    |추가적으로 필요한 공간(Overhead)|-|O(N)**|

    \* 원소 추가/제거 자체는 O(1)이지만 해당 위치를 찾아가는 시간이 추가적으로 필요  
    ** 각 원소가 다음 원소, 혹은 이전과 다음 원소의 주소값을 가져야하므로  
    32비트 컴퓨터의 경우 주소값이 32비트(=4바이트)이므로 4N 바이트가 추가로 필요하고  
    64비트 컴퓨터의 경우 주소값이 64비트(=8바이트)이므로 8N 바이트가 추가로 필요함

4. 포인터 2개를 사용하여 해결할 수 있다. n포인터로 헤더 노드를 가리키고 r포인터를 n부터 시작하여 n의 데이터와 r의 다음 노드의 데이터를 비교한다. 데이터가 같은 경우 r.next를 r.next.next로 하여 r의 다음 노드를 제거한다. 데이터가 다른 경우 r을 다음 노드로 이동시킨다. r이 리스트에 끝에 도달하면 n을 다음 노드로 이동하고 r을 다시 n과 같은 노드를 가리키게 하여 같은 작업을 반복한다. n의 다음 노드가 null일때 까지 반복하면 중복된 노드를 모두 제거할 수 있다.

5. [참고코드](https://github.com/DJ-archive/Algorithm-DataStructure/blob/main/0minyoung0/data_structure/linkedlist/KthToLast.java)
* (길이 측정) 전체 리스트를 한번 돌면서 전체 길이 l을 구하고 처음부터 l-k만큼 다시 이동한다.
* (재귀 사용) null이 나올때 까지 다음 노드의 주소를 가지고 재귀적으로 호출하고 null이 나올때를    base로 한다. 반환하여 나올 때마다 카운터를 증가시켜 k와 일치할때부터 해당 노드를 반환한다.
* (포인터 사용) p1을 k만큼 먼저 보내고 p1과 p2를 동시에 이동하다가 p1이 null에 도달하면 p2의 위치를 반환한다.
  
6. 삭제할 노드의 이전 노드에 접근할 수 없으므로 바로 삭제할 수 없다. 삭제할 노드의 다음 노드를 삭제할 노드에 복사하고 삭제할 노드의 다음 노드를 제거하면 된다. 이 경우 원래 삭제하려던 노드의 next 주소를 다다음 노드로 바꿔주면 된다. 추가로 이 방법을 통해서는 헤더 노드와 마지막 노드를 지울 수 없다.

7. [참고코드](https://github.com/DJ-archive/Algorithm-DataStructure/blob/main/0minyoung0/data_structure/linkedlist/Partition.java)
* (포인터 4개 사용) 왼쪽 리스트(시작 s1, 마지막 e1)와 오른쪽 리스트(시작 s2, 마지막 e2)를 각각 만들어서 노드를 추가하고 마지막에 두 리스트를 연결한다.
* (앞뒤로 붙이기) 빈 리스트에 head, tail 포인터를 주고 작은 값은 왼쪽에 추가하고 head를 그 위치로 옮기고, 큰 값은 오른쪽에 추가하고 tail을 그 위치로 옮긴다.
  
8. [참고코드](https://github.com/DJ-archive/Algorithm-DataStructure/blob/main/0minyoung0/data_structure/linkedlist/Sumlists.java)
* (기본문제) 각 리스트의 헤더부터 더하며 그 값을 10으로 나눈 나머지를 새 리스트에 저장한다. 더한 값이 10이상인 경우 다음 노드의 계산에 더해준다. 이때 올림값은 객체를 통해 전달한다.  
* (심화문제) 리스트의 길이를 먼저 계산하여 짧은 리스트의 앞에 자리수가 맞도록 0 노드를 추가한다. 이후 재귀적으로 마지막노드까지 접근하여 반환하며 아랫자리부터 계산한다.

9. [참고코드](https://github.com/DJ-archive/Algorithm-DataStructure/blob/main/0minyoung0/data_structure/linkedlist/IsPalindrome.java)
* (거꾸로 정렬) 거꾸로 정렬된 새 리스트를 만들어서 기존의 리스트와 처음부터 비교한다.
* (2개의 포인터) 빠른 포인터 f는 2노드씩 느린 포인터 s는 1노드씩 이동하며 s포인터가 스택에 노드의 데이터를 담는다. f가 마지막 노드나 null에 도착하면 s포인터를 이어서 이동시키며 스택에서 꺼낸 값과 비교한다. (f가 마지막 노드에 도달한 경우 전체 리스트의 길이가 홀수이므로 이를 고려해서 처리한다.)
* (재귀호출) 중간까지만 이동하며 재귀를 멈추기 위해 인자를 2씩 감소시키며 넘겨준다. 회귀하여 돌아가며 함수를 호출할 때 받았던 값과 중간에서 반환해준 다음 값을 비교한다. 다음 노드의 주소와 결과를 포함하는 객체를 반환시키며 전달한다.

10. 시작점을 저장해둔 후 동일한 노드가 나올 때 까지 계속 다음 노드로 가면 된다. 공간복잡도 O(1), 시간복잡도 O(N)

11. 두 리스트의 길이를 먼저 확인하여 끝을 맞춰준다. 긴 리스트의 앞에서 차이만큼 다음 노드로 진행하여 이후 두 리스트의 노드를 비교하고 다를 경우 다음 노드로 이동하면 된다. 공간복잡도 O(1), 시간복잡도 O(A+B)

12. 두칸 이동하는 fast 포인터와 한칸 이동하는 slow 포인터를 이용한다. 두 포인터가 만나면 s포인터를 시작점으로 옮기고 f포인터의 속도를 1로 변경하여 다시 이동시켜 두 포인터가 다시 만나는 노드가 루프의 시작노드이다. 두 포인터가 만나지 않고 f포인터가 null에 도달하면 루프는 없다.  
    
    <추가 설명>

    루프의 시작점을 0번노드, 그 다음부터 1,2,..번 노드라 하자  
    
    (Floyd's cycle-finding algorithm)  
    (시작 ~ f와 s가 만난다)  
    = (1. 시작 ~ s가 처음으로 루프 시작점 도착) + (2. s가 루프 시작점 도착 ~ f와 s가 만난다)  
    = k + (l-k)%l

    <1의 종료시점>  
    s는 0번노드, f는 k번노드에 도달  
    (엄밀 : f는 k%l번 노드에 도달)  
    <2의 종료시점>
    s과 l이 -k번노드에 도달  
    (엄밀 : 두포인터가 (-k)%l번 노드에 도달)  
    이제 만난 점에서 k칸 진행하면 0번 노드에 도달하므로  
    포인터 하나는 시작점에서부터 k만큼 진행하고 하나는 만난 점에서 k만큼 진행하면 0번 노드에서 만남