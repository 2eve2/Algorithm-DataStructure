## 트리의 종류

- Binary Tree (이진트리)

    노드에 자식이 최대 2개 붙은 트리

- Binary Search Tree (이진 검색 트리)

    이진트리이면서 노드의 값이 왼쪽 자식 < 현재 노드 < 오른쪽 자식 순을 유지하는 트리

- Balanced Tree (균형 트리)

    왼쪽 오른쪽 서브트리의 크기가 많이 차이 나지 않는 트리

    AVL Tree, Red-Black Tree가 대표적

- Complete Binary Tree (완전 이진 트리)

    레벨마다 모두 차있고 왼쪽부터 채워나가는 트리

- Full Binary Tree

    노드마다 자식이 2개 또는 0개 있는 트리

- Perfect Binary Tree

    모든 리프 노드는 자식이 0개, 그 외의 노드는 모두 2개의 자식 노드를 가지는 트리

## 자바에서의 트리

대표적인 라이브러리로 TreeMap과 TreeSet이 있다.

TreeMap은 각 노드가 키(중복 x)와 값으로 이루어져있고, TreeSet은 각 노드마다 값(중복 x)이 저장되어 있다.

둘 다 Red-Black Tree로 구현되어 있어 삽입, 조회, 삭제에서 O(logN)의 시간 복잡도를 보장한다.

또다른 자가 균형 트리인 AVL 트리보다 회전 연산이 적게 일어나 더 빠르다.

## 응용 문제

1. 정렬이 되어 있고, 고유한 정수로만 이루어진 배열을 이진검색트리로 옮기는 방법?

    pre-order 방식으로 이분 탐색을 진행하면서 매번 mid에 위치하는 값을 트리에 저장

2. 이진트리의 노드들을 각 레벨별로 리스트에 담는 방법?

    1. 재귀로 구현하면서 현재 단계에 해당하는 리스트에 노드를 저장
    2. BFS를 이용해서 매 거리마다 있는 노드를 저장

3. 주어진 이진트리의 밸런스가 맞는지 확인하는 방법? (밸런스가 맞다는 것은 임의의 노드의 양쪽 서브트리 길이 차이가 1보다 크지 않음)

    재귀로 리프노드까지 내려간 후 더 긴 서브트리에 길이를 1씩 더하면서 리턴, post-order방식으로 진행

4. 주어진 트리가 이진 검색 트리인지 확인하는 방법?

    inorder 순회 했을 때 노드들의 값이 증가하지 않으면 BST가 아님

5. 이진 검색 트리에서 주어진 노드의 다음 노드를 찾는 방법 (in-order 순으로)?

    오른쪽 자식이 없다면 현재노드가 부모의 왼쪽 자식일 때 까지 올라가서 부모 노드 반환, 있다면 아래로 내려가기(아래에서 가장 왼쪽)

6. 작업의 선후 관계를 그래프로 나타냈을 때 작업 순서를 반환하는 방법?

    위상 정렬을 진행한다.

7. 이진 트리에서 주어진 두 개의 노드의 첫번째 공통된 부모 노드를 찾기 (단, 다른 자료구조 사용 금지) : LCA

    1. 노드에서부터 루트까지 길이를 잰 후 길이를 맞추기 -> 한 칸씩 이동하면서 같은 칸이면 반환

    2. 부모노드에 연결된 반대 쪽 서브트리에 다른 노드가 있다면 그 부모노드가 최소 공통 조상

    3. post-order로 탐색하면서 좌우 서브트리 모두에서 두 노드를 찾은 순간이 LCA

8. 특정한 이진 검색 트리를 만드는 모든 배열(입력 순서) 찾는 방법?

    1. 특정 노드에서 왼쪽 자식과 오른쪽 자식을 삽입하는 순서는 서로 바뀌어도 상관이 없음
    2. 백트래킹

9. 트리 2개가 주어졌을 때 하나의 트리가 다른 트리의 서브트리인지 확인하는 방법?

    pre-order로 순회하면서 같은지 체크

10. 주어진 이진트리에서 연결된 노드의 합사이 특정한 수가 되는 경로의 개수를 세는 방법?

    1. 새로운 노드의 값을 더할 때마다 지금까지의 누적합에 돌아가면서 갱신하기
    2. 새로운 노드를 더할 때마다 누적합에서 구하려는 값을 뺐을 때 체크 되어있으면 개수를 +1 (해시맵 이용)

11. 두 종류의 순회 결과를 가지고 이진 탐색 트리를 복원하는 방법?

    1. preorder 순회 결과를 차례대로 이동하기
    2. preorder 결과의 매 인덱스마다 이전 인덱스보다 작은지 큰지 비교해서 왼쪽 자식인지 오른쪽자식인지 판단
    3. postorder 순회 결과라면 역순으로 진행
