[TOC]

# Array(배열)

* **인덱스를 입력하면 곧바로 해당 데이터에 즉시 접근가능하다는 장점**이 있다. O()

* 이를 가능하게 하기 위해  <u>내부적으로 모든데이터가 연속적으로 위치</u>되어서 인덱스만 입력하면 바로 해당 데이터의 주소값을 계산해낼 수 있다.

* 모든 데이터들이 연속적으로 위치하기 때문에, <u>배열을 선언할 때 데이터 갯수를 미리 지정</u>해 메모리를 미리 예약해놓고 사용해야 한다.
* 동일한 메모리 크기를 갖기 위해 저장되는 자료형이 고정되어 있다.

* **크기를 변경할 수 없고 배열에 데이터를 추가, 삭제 시 데이터 이동이 일어나 시간이 많이 걸린다는 단점이 있다.**





# List Interface (추상 데이터 타입)

추상 데이터 타입: 자료구조가 제공하는 **"기능"만 묘사**하고 **구체적으로 어떻게 구현되는지에 대한 정보는 없는 자료구조**. List, Queue, 등

**List**: 개념적으로 데이터를 나란히 저장하고 데이터의 위치에 상관없이 조회,삽입,변경,삭제가 가능한 자료형

-> **java에서는 LinkedList, ArrayList, Vector 로 구현 가능하다.**



# LinkedList(연결리스트)

![image-20230127104411969](C:\Users\SSAFY\Desktop\git\Algorithm-DataStructure\dajeong\data_structure\linkedlist\assets\image-20230127104411969.png)

* 각 요소가 다음 요소의 링크 정보를 가지는 선형 자료구조

* 각 요소를 Node로 정의하고 <u>Node는 다음 요소의 참조값(Next 필드)과 데이터(Data 필드)로 구성</u>되므로  원소들이 메모리 공간상에 <u>연속적으로 구성될 필요가 없다.</u>

* <u>데이터를 추가할 때 마다 동적으로 메모리를 할당하는 구조</u>이기 때문에, 데이터 추가에 한계가 없다.

* Java Collection - List Interface의 구현체인 LinkedList로 구현 가능

  

## 데이터 조회: O(N)

head 노드부터 시작하여 순차적으로 데이터를 조회해나가야하기 때문에 최악의 경우 O(N)의 성능을 갖는다.

연결리스트는 인덱스로 값의 접근이 O(1)로 가능한 배열에 비해 조회 속도가 느리다는 단점이 있다. 





## 데이터 삽입: O(1) / O(N)

![image-20230127110619771](C:\Users\SSAFY\Desktop\git\Algorithm-DataStructure\dajeong\data_structure\linkedlist\assets\image-20230127110619771.png)

순차리스트와는 다르게, 이후 데이터들을 뒤로 밀어줄 필요가 없다. 참조하고 있는 객체의 주소만 바꿔주면 되기 떄문에 기본적으로는 O(1)의 성능을 갖는다.

그러나, 삽입위치까지 가기위해 Head부터 데이터 참조를 하나씩 타고 가는 탐색 시간 때문에, 최악의 경우 가장 마지막 데이터까지 참조를 타고 가야 하므로 O(N)의 성능을 갖는다.



## 데이터 삭제: O(1) / O(N)

![image-20230127110554241](C:\Users\SSAFY\Desktop\git\Algorithm-DataStructure\dajeong\data_structure\linkedlist\assets\image-20230127110554241.png)

참조하고 있는 node를 그 다음 노드로 바꾸면 삭제할 수 있으며 기본적으로는 O(1) 의 성능을 갖는다.

하지만 최악의 경우 가장 마지막 데이터를 삭제하는 경우이다. 마지막 데이터까지 참조를 타고가는 탐색 시간이 있기 때문에 O(N)이다.



## 성능상 장단점

장점:

* 데이터 갯수만큼만 메모리를 사용하니 메모리 효율적이다.

* 데이터의 삽입 및 삭제가 수월하다. 

  * 배열과 비교해 연결리스트의 삽입, 삭제는 노드들 간에 포인터만 설정해주면 된다. 
  * 새로운 원소를 위해 다른 원소의 위치를 쉬프트할 필요가 없다.

  

단점:

* 인덱스로 데이터에 접근할때도 O(N)이다
  * Head 부터 참조를 하나씩 타고가야 하기 때문

* **캐쉬 친화적이지 않다**
  * 데이터를 추가할 때 마다, 동적으로 힙메모리를 할당해 참조한다. 따라서, 힙메모리에 여기저기 데이터주소가 분산될 확률이 높다.
  * 배열 요소는 연속된 메모리 공간상에 위치하므로 참조 지역성이 좋은 반면, 연결 리스트는 요소들이 링크되어 있고 메모리 상에 흩어져 존재하므로 참조 지역성이 없다.







# ArrayList (동적배열/순차리스트)

* 동적 배열은 내부 배열을 가지고 있다. 내부 배열을 통해 리스트를 구현한 형태.

* 동적배열 클래스 동작 방식
  : **데이터 갯수에 맞춰 내부 배열의 크기를 변경시키는 동작을 한다.** 
  데이터 갯수에 따라 동적으로 내부 배열의 크기를 새로 만들 수 있다. 데이터를 계속 추가하다가 내부적으로 선언한 크기를 넘어서게 되면 내부에 1/2배 크기만큼 공간을 늘린 배열을 선언하고, 거기에 데이터를 다 옮긴다. 데이터의 갯수가 적어질 때에도 내부 배열의 크기를 줄인다.

  > int newCapacity = oldCapacity + (oldCapacity >> 1);
  >
  > == oldCapacity + oldCapacity / 2

  * 많은 원소가 추가, 삭제가 되는 상황이라면 빈번하게 배열의 복사가 일어날 것이므로 ArrayList 객체를 만들 때 초기 용량을 설정해주는 것이 좋다. (DEFAULT_CAPACITY = 10)

* 이렇게 함으로써 인덱스 접근은 배열을 사용해 매우빠르게 가져가고, 메모리 낭비를 줄이고, 저장가능한 데이터갯수를 동적으로 변경시키는 것이 가능하다.

  

## 데이터 삽입: O(N)



![image-20230127111623866](C:\Users\SSAFY\Desktop\git\Algorithm-DataStructure\dajeong\data_structure\linkedlist\assets\image-20230127111623866.png)

데이터를 추가하려면 기존데이터를 한칸씩 뒤로 밀어줘야 한다. 새로운 공간을 확보해야 하기 때문이다.

최악의 경우, 맨 앞에 데이터를 추가하기 위해, N개 데이터 모두를 뒤로 한칸씩 밀어야 하기 때문에 O(N)의 성능을 갖는다.





## 데이터 삭제: O(N)

![image-20230127111845997](C:\Users\SSAFY\Desktop\git\Algorithm-DataStructure\dajeong\data_structure\linkedlist\assets\image-20230127111845997.png)

맨 앞 데이터 하나를 삭제할 때, 기존의 모든 데이터를 앞으로 한칸씩 당겨줘야 한다. 따라서 성능은 O(N)이다.



## 성능과 장단점

1. 삽입 → O(N)

2. 삭제 → O(N)

3. 특정 데이터 조회 → O(N)

4. **인덱스로 조회 → O(1)**



### 장점

1. "배열"로 구현하니까, 인덱스 조회가 매우 빠르다
   * 배열은 모든 데이터타입이 같고, 메모리에 연속적으로 위치해 있다. 따라서 인덱스를 통해 메모리주소를 O(1)에 계산해 접근할 수 있다.

2. 캐시 친화적이다
   * 배열은 데이터가 메모리공간에서 연속적으로 위치한다. 따라서, 캐시의 공간 지역성 원리에 의해 조회시에 높은 성능을 가질 확률이 높다.

### 단점

1. 원소를 삽입하고 삭제하는 연산이 연결리스트와 비교해 다소 비용이 많이 든다.
   * 원소를 저장할 공간이 만들어져야 하며, 특정 위치에 값을 삽입한다면 다른 원소를 한 칸 씩 쉬프트 해야할 수도 있다.
   * 삭제하는 연산의 경우 빈 공간을 채우기 위한 비용이 발생한다.





